{"version":3,"sources":["day8/re_frame_10x/inlined_deps/spade/git_sha_93ef290/util.cljc"],"mappings":";AAGA;;;;;;6EAAA,7EAAMA,kKAKHC;AALH,AAME,IAAMC,aAAoB,AAAQD;AAAlC,AAEE,GAAI,AAACE,uBAAOD;AAGV,OAACE,eAAK,+CAAA,/CAACC;;4EAKHH,vBACA,kCAAA,gBAAA,lDAACI,vBACD,6EAAA,OAAA,pFAACA,9BACD,uHAAA,KAAA,rHAACA;;;AAEX,qEAAA,rEAAMC,kJAAUC;AAAhB,0EACMA,1EAEA,8BAAA,+CAAA,iBAAA,vFAACF;;AAEP,2EAAA,3EAAMG,8JAAaC;AAAnB,AACE,IAAA,AACE,OAACE,eAAKF;gBADR,QAAAC,JAG4BE;AAH5B,AAAA;;AAMF,6EAAA,7EAAMC,kKAAkBC,KAAKC,UAAUC;AAAvC,AACE,oBAEED;AAAU,0DAAA,NAAKD,UAAS,AAACR,mEAASS;;AAFpC,GAIE,AAACE,cAAID;AAAQ,IAAAE,qBAAc,AAACV,yEAAYQ;AAA3B,AAAA,oBAAAE;AAAA,WAAAA,PAASC;AAAT,AACE,0DAAA,NAAKL,sDAASK;;AAEd,IAAMC,MAAI,CAAA,4EAAqCN;AAA/C,AACW,AAACO,aAAgBD;;AAE1BN;;;AAVnB,AAaQA","names":["day8.re-frame-10x.inlined-deps.spade.git-sha-93ef290.util/factory->name","factory","given-name","cljs.core/empty?","cljs.core/name","cljs.core.gensym","clojure.string/replace","day8.re-frame-10x.inlined-deps.spade.git-sha-93ef290.util/sanitize","s","day8.re-frame-10x.inlined-deps.spade.git-sha-93ef290.util/params->key","p","e20571","cljs.core/hash","_","day8.re-frame-10x.inlined-deps.spade.git-sha-93ef290.util/build-style-name","base","style-key","params","cljs.core/seq","temp__5802__auto__","pkey","msg","js/console.warn"],"sourcesContent":["(ns ^:no-doc day8.re-frame-10x.inlined-deps.spade.git-sha-93ef290.util\n  (:require [clojure.string :as str]))\n\n(defn factory->name\n  \"Given a style factory function, return an appropriate name for its\n   style. This function assumes it will be called *once* for any given\n   factory; subsequent calls for the same factory *may not* return the\n   same value (especially under :simple optimizations).\"\n  [factory]\n  (let [given-name #?(:cljs (.-name factory)\n                      :clj (-> factory meta :name str))]\n    (if (empty? given-name)\n      ; under :simple optimizations, the way the function is declared does\n      ; not leave any value for its name. so... generate one!\n      (name (gensym \"SPD\"))\n\n      ; normal case: base the style name on the factory function's name.\n      ; this lets us have descriptive names in dev, and concise names in\n      ; prod, without having to embed anything extra in the file\n      (-> given-name\n          (str/replace #\"[_-]factory\\$\" \"\")\n          (str/replace #\"[_$]\" \"-\")\n          (str/replace #\"^-\" \"_\")))))\n\n(defn sanitize [s]\n  (-> s\n      str\n      (str/replace #\"[^A-Za-z0-9-_]\" \"-\")))\n\n(defn params->key [p]\n  (try\n    (hash p)\n    (catch #?(:cljs :default\n              :clj Throwable) _\n      nil)))\n\n(defn build-style-name [base style-key params]\n  (cond\n    ; easy case: a key was provided\n    style-key (str base \"_\" (sanitize style-key))\n\n    (seq params) (if-let [pkey (params->key params)]\n                   (str base \"_\" pkey)\n\n                   (let [msg (str \"WARNING: no key provided for \" base)]\n                     #?(:cljs (js/console.warn msg)\n                        :clj (throw (Exception. msg)))\n                     base))\n\n    ; easiest case: no key is necessary\n    :else base))\n"]}